diff --git a/hw2/hw2.pdf b/hw2/hw2.pdf
index dfcc1f6..4da3afb 100644
Binary files a/hw2/hw2.pdf and b/hw2/hw2.pdf differ
diff --git a/hw2/hw2.tex b/hw2/hw2.tex
index a2aa717..c8f3ddc 100755
--- a/hw2/hw2.tex
+++ b/hw2/hw2.tex
@@ -73,8 +73,7 @@ October 30, 2017 & 12:30am & Isaac & Complete initial CLOOK implementation \\
    		 & 2:20am & Courtney & Design a plan to test the new scheduler \\
 		 & 3:45am & Courtney & Still working on how to test scheduler \\
 		 & 4:47am & Courtney and Isaac & Trying to figure out why CLOOK scheduler isn't printing/working, not having much success \\
-		 & 5:30pm & Courtney and Isaac & Working through Kernel Panic, trying to determine where the error is \\
-   		 & 7:30pm & Courtney and Isaac & Wrapping up assignment with final commits and documenting test plan \\
+		 & 5:30pm & Courtney and Isaac & Working through Kernel Panic, trying to determine where the error is \\ 
 \end{tabular}
 \end{center}
 
@@ -94,29 +93,10 @@ be sorted to the correct spot in the queue.
 
 To implement our selected algorithm, we made use of the Kernel's Linked List implementation. 
                 \item How did you ensure your solution was correct? Testing details, for instance.
-Our plan for testing was to run a python script that created a file and wrote to it. 
-This triggers file/IO steps that we can then check the system log for clook printouts. 
-However, because we were unsuccessful at getting the kernel to boot with our new I/O scheduler, we were unable to fully test the solution. 
-Once the CLOOK algorithm was written, we were able to select it as the default scheduler when building the kernel and the kernel was able to compile.
-We made the necessary adjustments to the qemu command by disabling virtio and changing \textit{root=/dev/vda} to \textit{root=/dev/hda}; however, when the qemu command was ran, there was a kernel panic. 
-We attempted for several hours to adjust our algorithm in order to avoid a kernel panic, but we were unable to determine the root of the problem. 
-We believe the problem was with our add request function, as that ended up being the only one we modified. 
-During the kernel boot, you can see "CLOOK add 2" which indicates that an add does occur, but immediately after an error occurs stating \textit{BUG: unable to handle kernel NULL pointer dereference at 0000008a}. 
-We are not 100 percent sure that this is the issue with the kernel panic, but we believe it may be attributed to it. 
 
+Our plan for testing was to run a python script that created a file and wrote to it. 
                 \item What did you learn?
-We learned about implementing an elevator algorithm and also with configuring a Linux kernel. We were able to change qemu flags to fit our needs.
-Even though we were not able to successfully apply our new scheduler and were unable to determine its correctness, we were able to learn quite a lot with regards to the Linux kernel. 
-
                 \item How should the TA evaluate your work? Provide detailed steps to prove correctness 
-			\begin{itemize}
-			\item Apply kernel patch file and build the kernel with \textit{make -j4 all}.
-			\item The build should ask you what scheduler to use; select CLOOK as the default.
-			\item Source the environment script.
-			\item Launch qemu with \textit{qemu-system-i386 -gdb tcp::5539 -S -nographic -kernel ./linux-yocto-3.19/arch/x86/boot/bzImage -drive file=core-image-lsb-sdk-qemux86.ext4,if=ide -enable-kvm -usb -localtime --no-reboot --append "root=/dev/hda rw console=ttyS0 debug"}
-			\item Connect to qemu with gdb \textit{target remote:5539} and \textit{continue}
-			\item There will be many CLOOK messages as the kernel boots.
-			\end{itemize}
 \end{enumerate}
 
 
diff --git a/hw2/unchanged_block/Kconfig.iosched b/hw2/unchanged_block/Kconfig.iosched
deleted file mode 100644
index 421bef9..0000000
--- a/hw2/unchanged_block/Kconfig.iosched
+++ /dev/null
@@ -1,68 +0,0 @@
-if BLOCK
-
-menu "IO Schedulers"
-
-config IOSCHED_NOOP
-	bool
-	default y
-	---help---
-	  The no-op I/O scheduler is a minimal scheduler that does basic merging
-	  and sorting. Its main uses include non-disk based block devices like
-	  memory devices, and specialised software or hardware environments
-	  that do their own scheduling and require only minimal assistance from
-	  the kernel.
-
-config IOSCHED_DEADLINE
-	tristate "Deadline I/O scheduler"
-	default y
-	---help---
-	  The deadline I/O scheduler is simple and compact. It will provide
-	  CSCAN service with FIFO expiration of requests, switching to
-	  a new point in the service tree and doing a batch of IO from there
-	  in case of expiry.
-
-config IOSCHED_CFQ
-	tristate "CFQ I/O scheduler"
-	default y
-	---help---
-	  The CFQ I/O scheduler tries to distribute bandwidth equally
-	  among all processes in the system. It should provide a fair
-	  and low latency working environment, suitable for both desktop
-	  and server systems.
-
-	  This is the default I/O scheduler.
-
-config CFQ_GROUP_IOSCHED
-	bool "CFQ Group Scheduling support"
-	depends on IOSCHED_CFQ && BLK_CGROUP
-	default n
-	---help---
-	  Enable group IO scheduling in CFQ.
-
-choice
-	prompt "Default I/O scheduler"
-	default DEFAULT_CFQ
-	help
-	  Select the I/O scheduler which will be used by default for all
-	  block devices.
-
-	config DEFAULT_DEADLINE
-		bool "Deadline" if IOSCHED_DEADLINE=y
-
-	config DEFAULT_CFQ
-		bool "CFQ" if IOSCHED_CFQ=y
-
-	config DEFAULT_NOOP
-		bool "No-op"
-
-endchoice
-
-config DEFAULT_IOSCHED
-	string
-	default "deadline" if DEFAULT_DEADLINE
-	default "cfq" if DEFAULT_CFQ
-	default "noop" if DEFAULT_NOOP
-
-endmenu
-
-endif
diff --git a/hw2/unchanged_block/Makefile b/hw2/unchanged_block/Makefile
deleted file mode 100644
index 00ecc97..0000000
--- a/hw2/unchanged_block/Makefile
+++ /dev/null
@@ -1,25 +0,0 @@
-#
-# Makefile for the kernel block layer
-#
-
-obj-$(CONFIG_BLOCK) := bio.o elevator.o blk-core.o blk-tag.o blk-sysfs.o \
-			blk-flush.o blk-settings.o blk-ioc.o blk-map.o \
-			blk-exec.o blk-merge.o blk-softirq.o blk-timeout.o \
-			blk-iopoll.o blk-lib.o blk-mq.o blk-mq-tag.o \
-			blk-mq-sysfs.o blk-mq-cpu.o blk-mq-cpumap.o ioctl.o \
-			genhd.o scsi_ioctl.o partition-generic.o ioprio.o \
-			partitions/
-
-obj-$(CONFIG_BOUNCE)	+= bounce.o
-obj-$(CONFIG_BLK_DEV_BSG)	+= bsg.o
-obj-$(CONFIG_BLK_DEV_BSGLIB)	+= bsg-lib.o
-obj-$(CONFIG_BLK_CGROUP)	+= blk-cgroup.o
-obj-$(CONFIG_BLK_DEV_THROTTLING)	+= blk-throttle.o
-obj-$(CONFIG_IOSCHED_NOOP)	+= noop-iosched.o
-obj-$(CONFIG_IOSCHED_DEADLINE)	+= deadline-iosched.o
-obj-$(CONFIG_IOSCHED_CFQ)	+= cfq-iosched.o
-
-obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o
-obj-$(CONFIG_BLK_CMDLINE_PARSER)	+= cmdline-parser.o
-obj-$(CONFIG_BLK_DEV_INTEGRITY) += bio-integrity.o blk-integrity.o t10-pi.o
-
diff --git a/hw2/unchanged_block/noop-iosched.c b/hw2/unchanged_block/noop-iosched.c
deleted file mode 100644
index 3de89d4..0000000
--- a/hw2/unchanged_block/noop-iosched.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * elevator noop
- */
-#include <linux/blkdev.h>
-#include <linux/elevator.h>
-#include <linux/bio.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-
-struct noop_data {
-	struct list_head queue;
-};
-
-static void noop_merged_requests(struct request_queue *q, struct request *rq,
-				 struct request *next)
-{
-	list_del_init(&next->queuelist);
-}
-
-static int noop_dispatch(struct request_queue *q, int force)
-{
-	struct noop_data *nd = q->elevator->elevator_data;
-
-	if (!list_empty(&nd->queue)) {
-		struct request *rq;
-		rq = list_entry(nd->queue.next, struct request, queuelist);
-		list_del_init(&rq->queuelist);
-		elv_dispatch_sort(q, rq);
-		return 1;
-	}
-	return 0;
-}
-
-static void noop_add_request(struct request_queue *q, struct request *rq)
-{
-	struct noop_data *nd = q->elevator->elevator_data;
-
-	list_add_tail(&rq->queuelist, &nd->queue);
-}
-
-static struct request *
-noop_former_request(struct request_queue *q, struct request *rq)
-{
-	struct noop_data *nd = q->elevator->elevator_data;
-
-	if (rq->queuelist.prev == &nd->queue)
-		return NULL;
-	return list_entry(rq->queuelist.prev, struct request, queuelist);
-}
-
-static struct request *
-noop_latter_request(struct request_queue *q, struct request *rq)
-{
-	struct noop_data *nd = q->elevator->elevator_data;
-
-	if (rq->queuelist.next == &nd->queue)
-		return NULL;
-	return list_entry(rq->queuelist.next, struct request, queuelist);
-}
-
-static int noop_init_queue(struct request_queue *q, struct elevator_type *e)
-{
-	struct noop_data *nd;
-	struct elevator_queue *eq;
-
-	eq = elevator_alloc(q, e);
-	if (!eq)
-		return -ENOMEM;
-
-	nd = kmalloc_node(sizeof(*nd), GFP_KERNEL, q->node);
-	if (!nd) {
-		kobject_put(&eq->kobj);
-		return -ENOMEM;
-	}
-	eq->elevator_data = nd;
-
-	INIT_LIST_HEAD(&nd->queue);
-
-	spin_lock_irq(q->queue_lock);
-	q->elevator = eq;
-	spin_unlock_irq(q->queue_lock);
-	return 0;
-}
-
-static void noop_exit_queue(struct elevator_queue *e)
-{
-	struct noop_data *nd = e->elevator_data;
-
-	BUG_ON(!list_empty(&nd->queue));
-	kfree(nd);
-}
-
-static struct elevator_type elevator_noop = {
-	.ops = {
-		.elevator_merge_req_fn		= noop_merged_requests,
-		.elevator_dispatch_fn		= noop_dispatch,
-		.elevator_add_req_fn		= noop_add_request,
-		.elevator_former_req_fn		= noop_former_request,
-		.elevator_latter_req_fn		= noop_latter_request,
-		.elevator_init_fn		= noop_init_queue,
-		.elevator_exit_fn		= noop_exit_queue,
-	},
-	.elevator_name = "noop",
-	.elevator_owner = THIS_MODULE,
-};
-
-static int __init noop_init(void)
-{
-	return elv_register(&elevator_noop);
-}
-
-static void __exit noop_exit(void)
-{
-	elv_unregister(&elevator_noop);
-}
-
-module_init(noop_init);
-module_exit(noop_exit);
-
-
-MODULE_AUTHOR("Jens Axboe");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("No-op IO scheduler");
